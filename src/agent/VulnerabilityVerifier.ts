/**
 * Vulnerability Verifier
 * Multi-model consensus verification for vulnerability findings
 * Updated to use Adversarial Debate System
 */

import { LLMClient } from './LLMClient';
import {
    AIVerificationResult,
    ModelVerdict,
    DetectorResult,
    Severity,
    ScanConfig
} from '../types';
import { logger } from '../core/Logger';
import { AdversarialVerifier } from './AdversarialVerifier';

export class VulnerabilityVerifier {
    private adversarialVerifier: AdversarialVerifier;

    constructor(config: ScanConfig) {
        this.adversarialVerifier = new AdversarialVerifier();
    }

    /**
     * Verify a vulnerability finding using adversarial debate
     */
    async verify(finding: DetectorResult): Promise<AIVerificationResult> {
        logger.debug('Running Adversarial Verification', { detector: finding.detectorName });

        try {
            const result = await this.adversarialVerifier.verify(finding);

            // Map Adversarial Result to AIVerificationResult
            return {
                isVulnerable: result.isConfirmed,
                confidence: result.confidence,
                severity: (result.modifiedSeverity as Severity) || finding.severity,
                modelVerdicts: [], // Legacy field
                reasoning: `[Adversarial Debate Verdict]\n${result.reasoning}\n\n[Debate Summary]\n${result.debateHistory.map(a => `${a.role.toUpperCase()}: ${a.point}`).join('\n')}`,
                falsePositiveLikelihood: 1 - result.confidence,
                cvssScore: finding.cvssScore, // Preserve original unless debate estimates one
                exploitationSteps: [],
                businessImpact: finding.impact,
            };

        } catch (error) {
            logger.error('Verification failed', error);
            return {
                isVulnerable: finding.vulnerable,
                confidence: finding.confidence,
                severity: finding.severity,
                modelVerdicts: [],
                reasoning: 'Adversarial verification failed due to error',
                falsePositiveLikelihood: 0,
            };
        }
    }
}
